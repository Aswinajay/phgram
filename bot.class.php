<?php
/**
* A simple class to Telegram bot development with PHP.
*
* Based on TelegramBotPHP (https://github.com/Eleirbag89/TelegramBotPHP)
*
* @author Cezar Pauxis
* @license https://github.com/usernein/phgram/blob/master/LICENSE
*/
class Bot {
	/**
	* The bot token. Acessible from outside.
	* @var string $bot_token
	*/
	public $bot_token = '';
	
	/**
	* The update data. Automatically filled when a new instance of the class is created.
	* All update-related methods uses this array. Can be set directly or using setData.
	* @var array $data
	*/
	public $data = [];
	
	/**
	* Contructor. Only needs the bot token. Fills the internal data and bot_token.
	*
	* @param string $bot_token Token generated by @BotFather
	*/
	public function __construct(string $bot_token) {
		$this->bot_token = $bot_token;
		$this->data = $this->getData();
	}
	
	/**
	* Private method. All method gets called by using cURL.
	*
	* @param string $url Url to API
	* @param array $content The method's parameters
	*
	* @return string A JSON containing the method's result. See https://core.telegram.org/bots/api#making-requests.
	*/
	private function sendAPIRequest(string $url, array $content) {
		$ch = curl_init($url);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($ch, CURLOPT_POST, TRUE);
		curl_setopt($ch, CURLOPT_POSTFIELDS, $content);
		$result = curl_exec($ch);
		curl_close($ch);
		return $result;
	}
	
	/**
	* Method to respond webhook. See https://core.telegram.org/bots/api#making-requests-when-getting-updates.
	*
	* @param string $method Method's name, according to Bot API.
	* @param array $args Method's parameters, according to Bot API.
	*/
	public function respondWebhook(string $method, array $args) {
		header("Content-Type: application/json");
		$args['method'] = $method;
		echo json_encode($args);
	}
	
	/**
	* The __call() magic method is called when the code calls a non-existing method. So you can call any API method and it will be called with a POST request.
	* Be carefully: __call() will be called with non-api methods, too. By the way, all methods are case-insentitive.
	*
	* @param string $method Method's name, according to Bot API.
	* @param array $args Method's parameters, according to Bot API.
	*
	* @return array An array containing the method's result. We'll call it as MethodResult. See https://core.telegram.org/bots/api#making-requests.
	*/
	public function __call(string $method, array $args = [[]]) {
		$url = "https://api.telegram.org/bot{$this->bot_token}/{$method}";
		$reply = $this->sendAPIRequest($url, $args[0]);
		
		return json_decode($reply, TRUE);
	}
	
	/**
	* Use it to download a file (present in Telegram servers) to your server.
	* Unfortunately it halts a bit during execution of code.
	*
	* @param string $file_id File id.
	* @param string $local_file_path Path to save the file. Optional. Default is according to the original file name, in the working directory.
	*
	* @return array [filename = saved file's name, filepath = saved file's path, filesize = saved file's size in bytes]
	*/
	public function download_file(string $file_id, string $local_file_path = NULL) {
		$telegram_file_info = $this->getFile(['file_id' => $file_id])['result'];
		$telegram_file_path = $telegram_file_info['file_path'];
		if (!$local_file_path) {
			$local_file_path = $telegram_file_info['file_name'];
		}
		$file_url = "https://api.telegram.org/file/bot{$this->bot_token}/{$telegram_file_path}";
		$in = fopen($file_url, 'rb');
		$out = fopen($local_file_path, 'wb');

		while ($chunk = fread($in, 8192)) {
			fwrite($out, $chunk, 8192);
		}
		fclose($in);
		fclose($out);
		
		return ['filename' => basename($local_file_path), 'filepath' => $local_file_path, 'filesize' => filesize($local_file_path)];
	}
	
	/**
	* Quicly sends a message with default parameters.
	* Note that this function is a shortcut. It requires only one parameter : the text.
	* A second parameter can be passed: the array of custom parameters to override the default ones:
	 * [chat_id = current chat, parse_mode = HTML, disable_web_page_preview = TRUE]
	*
	* @param string $text The text to send (0-4096)
	* @param array $params (Optional) Custom parameters.
	*
	* @return array MethodResult (sendMessage)
	*/
	public function send(string $text, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE];
		foreach ($params as $param => $value) {
			$default[$param] = $value;
		}
		$default['text'] = $text;
		return $this->sendMessage($default);
	}
	
	/**
	* Replies a message (specified by reply_to()).
	* Same as send(), but uses reply_to() to get a message_id to reply.
	*
	* @param string $text The text to send (0-4096)
	* @param array $params (Optional) Custom parameters.
	*
	* @return array MethodResult (sendMessage)
	*/
	public function reply(string $text, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE, 'reply_to_message_id' => $this->reply_to()];
		foreach ($params as $param => $value) {
			$default[$param] = $value;
		}
		$default['text'] = $text;
		return $this->sendMessage($default);
	}
	
	/**
	* Use to quickly edit a message.
	* Same syntax as reply() and send(), but with an additional value.
	*
	* @param string $text The new text
	* @param int $message_id Id of message to edit.
	* @param array $params (Optional) Custom parameters.
	*
	* @return array MethodResult (editMessageTexf)
	*/
	public function edit(string $text, int $message_id, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE];
		foreach ($params as $param => $value) {
			$default[$param] = $value;
		}
		$default['text'] = $text;
		$default['message_id'] = $message_id;
		return $this->editMessageText($default);
	}

	/**
	* Quickly uploads a local file.
	* Has the same default paramenters of send().
	* 
	* @param string $filename Relative path to file
	* @param array $params (Optional) Custom parameters.
	*
	* @return array MethodResult (sendDocument)
	*/
	public function doc(string $filename, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE];
		foreach ($params as $param => $value) {
			$default[$param] = $value;
		}
		$document = curl_file_create(realpath($filename));
		if ($document) {
			$this->action("upload_document");
		}
		$default['document'] = $document;
		return $this->sendDocument($default);
	}
	
	/**
	* Quickly sends a chat action.
	* Has the chat_id set to current chat, by default.
	* 
	* @param string $action (Optional) Action to send. Defaults to 'typing'.
	* @param array $params (Optional) Custom parameters.
	*
	* @return array MethodResult (sendChatAction)
	*/
	public function action(string $action = 'typing', array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'action' => $action];
		foreach ($params as $param => $value) {
			$default[$param] = $value;
		}
		return $this->sendChatAction($default);
	}
	
	/**
	* Use it to get the data of the update.
	* 
	* @param void
	*
	* @return array Update. See https://core.telegram.org/bots/api#update
	*/
	public function getData() {
		if ($this->data == []) {
			$rawData = file_get_contents('php://input');
			return json_decode($rawData, TRUE);
		} else {
			return $this->data;
		}
	}

	/**
	* Changes the value of internal $data. Then it can be used in Text(), ChatID(), UserID()...
	* 
	* @param array $data New value to use
	*/
	public function setData(array $data) {
		$this->data = $data;
	}
	
	/**
	* Use it to get the type of an update.
	* All updates has the following syntax: [update_id = integer, TYPE = array]
	* Well, this method will return the TYPE.
	* 
	* @param void
	*
	* @retuen string Update's type.
	*/
	public function getUpdateType() {
		return @array_keys($this->data)[1];
	}
	
	/**
	* A simple and smart method to get, dinamically, a message_id to reply.
	*
	* @param void
	*
	* @result If the user's message is a reply (has reply_to_message), message_id of replied message. Otherwise, returns the message_id of user's message.
	*/
	public function reply_to() {
		if ($this->ReplyToMessage()) {
			return $this->ReplyToMessage()['message_id'];
		}
		return $this->MessageID();
	}
	
	/**
	* Use to check if a user is in the specified chat.
	*
	* @param int $user_id Id of user.
	* @param $chat_id Id of chat.
	*
	* @return bool
	*/
	public function in_chat(int $user_id, $chat_id) {
		$member = $this->getChatMember(['chat_id' => $chat_id, 'user_id' => $user_id]);
		if (!$member['ok'] or in_array($member['status'], ['left', 'restricted', 'kicked'])) {
			return FALSE;
		}
		
		return TRUE;
	}
	
	/**
	* Use it to quickly check if the chat is a supergroup.
	*
	* @param void
	*
	* @return bool
	*/
	public function is_group() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['chat'])) {
			return ($this->data[$type]['chat']['type'] == 'supergroup');
		} elseif (isset($this->data[$type]['message']['chat'])) {
			return ($this->data[$type]['message']['chat']['type'] == 'supergroup');
		}
		return FALSE;
	}
	
	/**
	* Use it to quickly check if the chat is a private conversation (user-bot).
	*
	* @param void
	*
	* @return bool
	*/
	public function is_private() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['chat'])) {
			return ($this->data[$type]['chat']['type'] == 'private');
		} elseif (isset($this->data[$type]['message']['chat'])) {
			return ($this->data[$type]['message']['chat']['type'] == 'private');
		}
		return FALSE;
	}
	
	/**
	* You can use any method below to get, dinamically, specific info about an update.
	* Simply call '$text = $bot->Text();' and you will get the text of the update, regardless of type (i.e. channel_post, message, edited_* or even callback_query).
	* If the update does not have 'text', the method will return NULL
	*
	* @param void
	*/
	public function Text() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['text'])) {
			return $this->data[$type]['text'];
		} elseif (isset($this->data[$type]['message']['text'])) {
			return $this->data[$type]['message']['text'];
		}
		
		return NULL;
	}

	public function ChatID() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['chat']['id'])) {
			return $this->data[$type]['chat']['id'];
		} elseif (isset($this->data[$type]['message']['chat']['id'])) {
			return $this->data[$type]['message']['chat']['id'];
		}
		
		return NULL;
	}

	public function MessageID() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['message_id'])) {
			return $this->data[$type]['message_id'];
		} elseif (isset($this->data[$type]['message']['message_id'])) {
			return $this->data[$type]['message']['message_id'];
		}
		
		return NULL;
	}

	public function Date() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['date'])) {
			return $this->data[$type]['date'];
		} elseif (isset($this->data[$type]['message']['date'])) {
			return $this->data[$type]['message']['date'];
		}
		
		return NULL;
	}

	public function UserID() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['from']['id'])) {
			return $this->data[$type]['from']['id'];
		} elseif (isset($this->data[$type]['message']['from']['id'])) {
			return $this->data[$type]['message']['from']['id'];
		}
		
		return NULL;
	}

	public function FirstName() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['from']['first_name'])) {
			return $this->data[$type]['from']['first_name'];
		} elseif (isset($this->data[$type]['message']['from']['first_name'])) {
			return $this->data[$type]['message']['from']['first_name'];
		}
		
		return NULL;
	}

	public function LastName() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['from']['last_name'])) {
			return $this->data[$type]['from']['last_name'];
		} elseif (isset($this->data[$type]['message']['from']['last_name'])) {
			return $this->data[$type]['message']['from']['last_name'];
		}
		
		return NULL;
	}

	public function Username() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['from']['username'])) {
			return $this->data[$type]['from']['username'];
		} elseif (isset($this->data[$type]['message']['from']['username'])) {
			return $this->data[$type]['message']['from']['username'];
		}
		
		return NULL;
	}

	public function ReplyToMessage() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['reply_to_message'])) {
			return $this->data[$type]['reply_to_message'];
		} elseif (isset($this->data[$type]['message']['reply_to_message'])) {
			return $this->data[$type]['message']['reply_to_message'];
		}
		
		return NULL;
	}

	public function Caption() {
		$type = $this->getUpdateType();
		if (isset($this->data[$type]['caption'])) {
			return $this->data[$type]['caption'];
		} elseif (isset($this->data[$type]['message']['caption'])) {
			return $this->data[$type]['message']['caption'];
		}
		
		return NULL;
	}
	
	public function InlineQuery() {
		return $this->data['inline_query'] ?? NULL;
	}

	public function ChosenInlineResult() {
		return $this->data['chosen_inline_result'] ?? NULL;
	}

	public function ShippingQuery() {
		return $this->data['shipping_query'] ?? NULL;
	}

	public function PreCheckoutQuery() {
		return $this->data['pre_checkout_query'] ?? NULL;
	}

	public function CallbackQuery() {
		return $this->data['callback_query'] ?? NULL;
	}

	public function Location() {
		$type = $this->getUpdateType();
		return $this->data[$type]['location'] ?? NULL;
	}

	public function Photo() {
		$type = $this->getUpdateType();
		return $this->data[$type]['photo'] ?? NULL;
	}

	public function Video() {
		$type = $this->getUpdateType();
		return $this->data[$type]['video'] ?? NULL;
	}

	public function Document() {
		$type = $this->getUpdateType();
		return $this->data[$type]['document'] ?? NULL;
	}

	public function UpdateID() {
		return $this->data['update_id'] ?? NULL;
	}
	
	public function ForwardFrom() {
		$type = $this->getUpdateType();
		return $this->data[$type]['forward_from'] ?? NULL;
	}

	public function ForwardFromChat() {
		$type = $this->getUpdateType();
		return $this->data[$type]['forward_from_chat'] ?? NULL;
	}
	
	/**
	* Shortcut to getChat.
	*
	* @param (Optional) $chat_id ID of chat. Default is the current chat.
	*
	* @return array Chat object || bool FALSE. See https://core.telegram.org/bots/api#chat
	*/
	public function Chat($chat_id = NULL) {
		if (!$chat_id) {
			$chat_id = $this->ChatID();
		}
		$chat = $this->getChat(['chat_id' => $chat_id]);
		if ($chat['ok']) {
			return $chat['result'];
		}
		return FALSE;
	}
}

/**
* Build an InlineKeyboardButton object.
* The type can be ommitted. Passing two parameters (text and value), the type will be assumed 'callback_data'.
*
* @param string $text Text to show in the button.
* @param string $param Value to button.
* @param string $type (Optional) Type of button. Defaults to callback_data.
*
* @return array InlineKeyboardButton object. See https://core.telegram.org/bots/api#inlinekeyboardbutton
*/
function btn(string $text, string $param, string $type = 'callback_data') {
	return ['text' => $text, $type => $param];
}

/**
* Build a KeyboardButton object.
* Is recommended to use only when you need to request contact or location.
* If you need a simple text button, pass a string instead of KeyboardButton.
*
* @param string $text Button text.
* @param bool (Optional) $request_contact Will the button ask for user's phone number? Defaults to FALSE.
* @param bool (Optional) $request_location Will the button ask for user's location? Defaults to FALSE.
* 
* @return array KeyboardButton object. See https://core.telegram.org/bots/api#keyboardbutton
*/
function kbtn(string $text, bool $request_contact = FALSE, bool $request_location = FALSE) {
	$replyMarkup = [
		'text' => $text,
		'request_contact' => $request_contact,
		'request_location' => $request_location,
	];
	return $replyMarkup;
}

/**
* Build a ReplyKeyboardMarkup object.
* 
* @param array $options Array (keyboard/set of lines) of array (line/set of buttons) of KeyboardButton, generated by kbtn() or strings.
* @param bool $onetime (Optional) If TRUE, the keyboard will be closed after using a button. Default is  FALSE.
* @param bool $resize (Optional) If TRUE, the keyboard will allow user's client to resize it. Default is FALSE.
* @param bool $selective (Optional) If TRUE, the keyboard willpp appear only to certain users. Dafault is TRUE.
*
* @return string/JSON ReplyKeyboardMarkup object. See https://core.telegram.org/bots/api#replykeyboardmarkup
*/
function kb(array $options, bool $onetime = FALSE, bool $resize = FALSE, bool $selective = TRUE) {
	$replyMarkup = [
		'keyboard' => $options,
		'one_time_keyboard' => $onetime,
		'resize_keyboard' => $resize,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, TRUE);
}

/**
* Build an InlineKeyboardMarkup object.
*
* @param array $options Array (keyboard/set of lines) of array (line/set of buttons) of array of parameters to pass to btn(). See the documentation for example.
*
* @return string/JSON InlineKeyboardMarkup object. See https://core.telegram.org/bots/api#inlinekeyboardmarkup
*/
function ikb(array $options) {
	$lines = [];
	foreach ($options as $line_pos => $line_buttons) {
		$lines[$line_pos] = [];
		foreach ($line_buttons as $button_pos => $button) {
			$lines[$line_pos][$button_pos] = btn(...$button);
		}
	}
	$replyMarkup = [
		'inline_keyboard' => $lines,
	];
	return json_encode($replyMarkup, TRUE);
}

/**
* Build a RepkyKeyboardRemove object.
*
* @param bool (Optional) $selective If TRUE, the keyboard will disappear only for certain users. Default is TRUE.
*
* @return string/JSON RepkyKeyboardRemove object. See https://core.telegram.org/bots/api#replykeyboardremove
*/
function hide_kb(bool $selective = TRUE) {
	$replyMarkup = [
		'remove_keyboard' => TRUE,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, TRUE);
}

/**
* Build a ForceReply object.
*
* @param bool (Optional) $selective If TRUE, the forceReply will affect only to certain users. Default is TRUE.
*
* @return string/JSON ForceReply object. See https://core.telegram.org/bots/api#forcereply
*/
function forceReply(bool $selective = TRUE) {
	$replyMarkup = [
		'force_reply' => TRUE,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, TRUE);
}